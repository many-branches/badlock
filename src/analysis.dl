// Relation definitions
.decl def(var: symbol, inst: symbol)
.input def
.decl out(inst: symbol, def_inst: symbol)
.decl in(inst: symbol, def_inst: symbol)
.decl next(prev_inst: symbol, inst: symbol)
.input next
.decl edge(from_inst: symbol, to_inst: symbol, var: symbol)
.decl path(from_inst: symbol, to_inst: symbol, var: symbol)
.decl lock(inst: symbol, var: symbol)
.input lock
.decl release(inst: symbol, var: symbol)
.input release
.decl wrap(wrapper: symbol, var: symbol)
.decl use(var: symbol, inst: symbol)
.input use
.decl deadlock(acquired_inst: symbol, var: symbol, reentrant_inst: symbol)
.output deadlock

// Reaching definitions
kill(curr_inst, old_inst) :- def(var, curr_inst), def(var, old_inst).
out(inst, inst) :- def(_, inst).
out(inst, def_inst) :- in(inst, def_inst), !kill(inst, def_inst).
in(inst, def_inst) :- out(prev_inst, def_inst), next(prev_inst, inst).

// Deadlock taint
edge(from_inst, to_inst, var) :- def(var, from_inst), use(var, to_inst), in(to_inst, from_inst).
edge(from_inst, to_inst, var) :- wrap(wrapper, var), use(wrapper, to_inst), in(to_inst, from_inst).
path(from_inst, to_inst, var) :- lock(from_inst, var), edge(from_inst, to_inst, var).
path(prev, next, var) :- path(prev, almost, var), !release(almost, var), edge(almost, next, var).
deadlock(acquired_inst, var, reentrant_inst) :- lock(reentrant_inst, var), path(acquired_inst, reentrant_inst, var).